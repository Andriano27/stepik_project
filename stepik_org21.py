# Оптимизируйте приведённый ниже код, реализующий алгоритм пузырьковой сортировки.
a = [17, 24, 91, 96, 67, -27, 79, -71, -71, 58, 48, 88, 88, -16, -78, 96, -76, 56, 92, 1, 32, -17, 36, 88, -61, -97, -37, -84, 50, 47, 94, -6, 52, -76, 93, 14, -32, 98, -65, -16, -9, -68, -20, -40, -71, 93, -91, 44, 25, 79, 97, 0, -94, 7, -47, -96, -55, -58, -78, -78, -79, 75, 44, -56, -41, 38, 16, 70, 17, -17, -24, -83, -74, -73, 11, -26, 63, -75, -19, -13, -51, -74, 21, -8, 21, -68, -66, -84, -95, 78, 69, -29, 39, 38, -55, 7, -11, -26, -62, -84]
n = len(a)
for i in range(n - 1):
    for j in range(n - 1 - i):
        if a[j] > a[j + 1]:
            a[j], a[j + 1] = a[j + 1], a[j]
print(a)

a = [17, 24, 91, 96, 67, -27, 79, -71, -71, 58, 48, 88, 88, -16, -78, 96, -76, 56, 92, 1, 32, -17, 36, 88, -61, -97,
     -37, -84, 50, 47, 94, -6, 52, -76, 93, 14, -32, 98, -65, -16, -9, -68, -20, -40, -71, 93, -91, 44, 25, 79, 97, 0,
     -94, 7, -47, -96, -55, -58, -78, -78, -79, 75, 44, -56, -41, 38, 16, 70, 17, -17, -24, -83, -74, -73, 11, -26, 63,
     -75, -19, -13, -51, -74, 21, -8, 21, -68, -66, -84, -95, 78, 69, -29, 39, 38, -55, 7, -11, -26, -62, -84]
n = len(a)
for i in range(n - 1):
    exchanges = 0
    for j in range(n - i - 1):
        if a[j] > a[j + 1]:
            exchanges += 1
            a[j], a[j + 1] = a[j + 1], a[j]
    if exchanges == 0:
        break
print(a)

a = [17, 24, 91, 96, 67, -27, 79, -71, -71, 58, 48, 88, 88, -16, -78, 96, -76, 56, 92, 1, 32, -17, 36, 88, -61, -97,
     -37, -84, 50, 47, 94, -6, 52, -76, 93, 14, -32, 98, -65, -16, -9, -68, -20, -40, -71, 93, -91, 44, 25, 79, 97, 0,
     -94, 7, -47, -96, -55, -58, -78, -78, -79, 75, 44, -56, -41, 38, 16, 70, 17, -17, -24, -83, -74, -73, 11, -26, 63,
     -75, -19, -13, -51, -74, 21, -8, 21, -68, -66, -84, -95, 78, 69, -29, 39, 38, -55, 7, -11, -26, -62, -84]
n = len(a)
swap = True  # задаём сигнальную метку
for i in range(n - 1):
    if swap == False:  # если по окончании внешнего цикла сигнальная метка приняла значение False,
        # то есть ни одного обмена не было произведено, тогда программа прерывается
        break
    for j in range(n - i - 1):
        if a[j] > a[j + 1]:
            a[j], a[j + 1] = a[j + 1], a[j]
            swap = True  # если в данном внутреннем цикле была произведена хотя бы одна перестановка
            # во внутреннем цикле, сигнальная метка принимает значение True
        else:
            swap = False  # если в данном внутреннем цикле не было произведено ни одной перестановки,
            # сигнальная метка сохраняет значение False
print(a)

import time
start_time = time.time()
# тут то, скорость чего хотим замерить
print("--- %s seconds ---" % (time.time() - start_time))

# Отсортируйте список по возрастанию, реализовав алгоритм сортировки выбором.
a = [78, -32, 5, 39, 58, -5, -63, 57, 72, 9, 53, -1, 63, -97, -21, -94, -47, 57, -8, 60, -23, -72, -22, -79, 90, 96,
     -41, -71, -48, 84, 89, -96, 41, -16, 94, -60, -64, -39, 60, -14, -62, -19, -3, 32, 98, 14, 43, 3, -56, 71, -71,
     -67, 80, 27, 92, 92, -64, 0, -77, 2, -26, 41, 3, -31, 48, 39, 20, -30, 35, 32, -58, 2, 63, 64, 66, 62, 82, -62, 9,
     -52, 35, -61, 87, 78, 93, -42, 87, -72, -10, -36, 61, -16, 59, 59, 22, -24, -67, 76, -94, 59]
n = len(a)
for i in range(n-1):  # внешний цикл - пройдется по всем элементам списка, кроме последнего
    min_index = i  # считаем что текущий элемент - минимальный
    for j in range(i + 1, n):  # внутренний цикл ищет минимальный элемент в оставшейся части списка
        if a[j] < a[min_index]:  # если нашли элемент меньше текущего минимального - запоминаем его индекс
            min_index = j
    a[i], a[min_index] = a[min_index], a[i]  # меняем местами минимальный элемент a[min_index] и текущий a[i]
print(a)

a = [78, -32, 5, 39, 58, -5, -63, 57, 72, 9, 53, -1, 63, -97, -21, -94, -47, 57, -8, 60, -23, -72, -22, -79, 90, 96, -41, -71, -48, 84, 89, -96, 41, -16, 94, -60, -64, -39, 60, -14, -62, -19, -3, 32, 98, 14, 43, 3, -56, 71, -71, -67, 80, 27, 92, 92, -64, 0, -77, 2, -26, 41, 3, -31, 48, 39, 20, -30, 35, 32, -58, 2, 63, 64, 66, 62, 82, -62, 9, -52, 35, -61, 87, 78, 93, -42, 87, -72, -10, -36, 61, -16, 59, 59, 22, -24, -67, 76, -94, 59]
n = len(a)
b = []  # создаем пустой список
while len(a) > 0:  # пока значение длины списка больше 0
    b.append(min(a))  # добавляем в новый список минимальное значение из старого списка
    a.remove(min(a))  # после добавления в новый список удаляем это значение из старого
print(b)

a = [78, -32, 5, 39, 58, -5, -63, 57, 72, 9, 53, -1, 63, -97, -21, -94, -47, 57, -8, 60, -23, -72, -22, -79, 90, 96, -41, -71, -48, 84, 89, -96, 41, -16, 94, -60, -64, -39, 60, -14, -62, -19, -3, 32, 98, 14, 43, 3, -56, 71, -71, -67, 80, 27, 92, 92, -64, 0, -77, 2, -26, 41, 3, -31, 48, 39, 20, -30, 35, 32, -58, 2, 63, 64, 66, 62, 82, -62, 9, -52, 35, -61, 87, 78, 93, -42, 87, -72, -10, -36, 61, -16, 59, 59, 22, -24, -67, 76, -94, 59]
print([a.pop(a.index(min(a))) for i in range(len(a))])

a = [78, -32, 5, 39, 58, -5, -63, 57, 72, 9, 53, -1, 63, -97, -21, -94, -47, 57, -8, 60, -23, -72, -22, -79, 90, 96, -41, -71, -48, 84, 89, -96, 41, -16, 94, -60, -64, -39, 60, -14, -62, -19, -3, 32, 98, 14, 43, 3, -56, 71, -71, -67, 80, 27, 92, 92, -64, 0, -77, 2, -26, 41, 3, -31, 48, 39, 20, -30, 35, 32, -58, 2, 63, 64, 66, 62, 82, -62, 9, -52, 35, -61, 87, 78, 93, -42, 87, -72, -10, -36, 61, -16, 59, 59, 22, -24, -67, 76, -94, 59]
n = len(a)
for i in range(n):  # Кол-во циклов = кол-ву чисел в списке
    aa = a[:n]  # Ещё неупорядоченная часть строки
    ind = aa.index(max(aa))  # Индекс максимального числа неупорядоченного отрезка
    aa[ind], aa[-1] = aa[-1], aa[ind]  # Меняем местами максимум и последнее число в списке
    a = aa + a[n:]  # Склеиваем неупорядоченную и упорядоченную части в обновленную строку
    n -= 1  # Новая неупорядоченная часть в след цикле будет на 1(последний элемент короче),
    # а упорядоченная - длиннее
print(a)
