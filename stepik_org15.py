# В некотором наборе слов Сэм находит "волшебное" число по следующему алгоритму:
# берет самую "маленькую" и самую "большую" строки, перемножает Unicode-коды последних символов этих строк
# и возводит полученное число в квадрат. Результатом и является "волшебное" число.
#  На вход программе подаются 4 слова. Найдите "волшебное" число в этом наборе слов.
word1 = input()
word2 = input()
word3 = input()
word4 = input()
small = min(word1, word2, word3, word4)
big = max(word1, word2, word3, word4)
last_small = small[-1]
last_big = big[-1]
print((ord(last_small) * ord(last_big)) ** 2)

world = input()
max_w = world
min_w = world
for i in range(3):  # счетчик меньше на 1, так как вначале уже введена одна строка
    world = input()
    max_w = max(max_w, world)
    min_w = min(min_w, world)
    # print(max_w, min_w)
miracle_digit = (ord(max_w[-1]) * ord(min_w[-1])) ** 2
print(miracle_digit)

s = input()
maxs = s
mini = s
count = 0
while count != 3:
    if count == 3:
        break
    count += 1
    s = input()
    mini = min(mini, s)
    maxs = max(maxs, s)
print((ord(mini[-1]) * ord(maxs[-1])) ** 2)

# На вход программе подаётся последовательность строк, каждая строка на отдельной строке.
# Концом последовательности является слово «КОНЕЦ» (без кавычек). При этом само слово «КОНЕЦ» не входит
# в последовательность, лишь символизируя ее окончание. Напишите программу, которая находит в данной
# последовательности максимальную и минимальную строки (в лексикографическом порядке) и выводит
# их в следующем формате: Минимальная строка ⬇️: <минимальная строка>
# Максимальная строка ⬆️: <максимальная строка>
text = input()  # первое значение считываем перед циклом, чтобы было с чем сравнивать
mn_text = text
mx_text = text
while text != 'КОНЕЦ':
    mx_text = max(mx_text, text)  # в цикле обновляем минимум и максимум
    mn_text = min(mn_text, text)
    text = input()  # переход к следующей строке
print('Минимальная строка ⬇️:', mn_text)
print('Максимальная строка ⬆️:', mx_text)

# На вход программе подаются 2 строки. Вам необходимо сравнить эти строки посимвольно, не учитывая регистр
# и игнорируя все небуквенные символы. Программа должна вывести «YES» (без кавычек), если строки окажутся
# равны в результате такой проверки, или «NO» (без кавычек) в противном случае.
s = input()
t = input()
count_s = ''
count_t = ''
for i in s:
    if i.isalpha() == True:  # проверяем каждый символ строки, является ли он буквой
        count_s += i  # если буква, добавляем в новую строку
for j in t:
    if j.isalpha() == True:
        count_t += j
s1 = count_s.lower()  # приводим новые строки из букв к единому регистру
t1 = count_t.lower()
if s1 == t1:  # сравниваем строки
    print('YES')
else:
    print('NO')

# В школе BEEGEEK названия учебных классов необычные. Они имеют следующий формат: <номер класса><буква класса>
# где <номер класса> должен находиться в диапазоне от 0 (как и все у программистов) до 9 включительно,
# а буквой класса могут быть все буквы в диапазоне от «А» до «П» включительно. Напишите программу, которая
# принимает натуральное число n, а далее n названий классов, каждое на новой строке. Для каждого названия
# класса ваша программа должна выводить на отдельной строке «YES» (без кавычек), если название класса
# корректное, или «NO» (без кавычек) в противном случае.
n = int(input())  # вводим количество строк
for i in range(n):  # циклом задаем количество введенных строк
    s = input()  # вводим строки
    if len(s) == 2 and '0' <= s[0] <= '9' and ord('А') <= ord(s[1]) < ord('Р'):  # если длинна строки равна
        # двум символам, первый символ по индексу имеет численное значение от 0 до 9, второй символ по индексу
        # находится в диапазоне русского алфавита символов Unicode от А до П.
        print('YES')
    else:
        print('NO')

n = int(input())
for _ in range(n):
    class_name = input()
    if (
        len(class_name) == 2
        and '0' <= class_name[0] <= '9'
        and 'А' <= class_name[1] <= 'П'
    ):
        print('YES')
    else:
        print('NO')

n = int(input())
num = '0123456789'
letters = 'АБВГДEЖЗИЙКЛМНОП'
for i in range(n):
    n = input()
    if len(n) == 2:
        if n[0] in num and n[-1] in letters:
            print('YES')
        else:
            print('NO')
    else:
        print('NO')

# На вход программе подаются 3 различных слова. Вам необходимо отсортировать эти слова по возрастанию
# в лексикографическом порядке и вывести их на одной строке, разделяя символом пробела.
s = input()
p = input()
t = input()
first = min(s, p, t)
last = max(s, p, t)
middle = s + p + t
middle = middle.replace(first, '')
middle = middle.replace(last, '')
print(first, middle, last, end='')

a = input()
b = input()
c = input()
first = min(a, b, c)
last = max(a, b, c)
if a > b > c or a < b < c:
    middle = b
elif a > c > b or a < c < b:
    middle = c
else:
    middle = a
print(first, middle, last, end='')

# Все книги в домашней библиотеке Душнилы, друга Сэма, должны быть обязательно отсортированы по возрастанию:
# сначала по фамилиям авторов, а в случае совпадения фамилий – по названиям. Напишите программу, которая
# проверяет, верно ли отсортированы книги. На вход программе подаются число n, а затем – n строк,
# каждая строка представляет собой книгу в следующем формате: <фамилия автора> <инициалы автора>,
# «<название книги>» Программа должна вывести «YES» (без кавычек), если книги отсортированы в соответствии
# с пожеланиями Душнилы, или «NO» (без кавычек) в противном случае.
n = int(input())          # количество книг
prev = input().strip()    # первая книга (сохраняем для сравнения)
for _ in range(n - 1):    # остальные n-1 книг
    curr = input().strip()    # читаем текущую книгу
    # фамилия предыдущего автора = всё до первого пробела
    last1 = prev[:prev.find(" ")]  # от начала строки до первого пробела между фамилией и именем
    # фамилия текущего автора
    last2 = curr[:curr.find(" ")]
    if last1 > last2:         # если фамилия идёт "назад" по алфавиту
        print("NO")
        break
    if last1 == last2:        # если фамилии одинаковые, сравним названия
        # название книги — текст между « и »
        title1 = prev[prev.find("«") + 1: prev.rfind("»")]   # вырезаем название книги из кавычек
        title2 = curr[curr.find("«") + 1: curr.rfind("»")]   # чтобы '«' не попала в срез, добавляем +1,
        # последняя не попадет, так как вторая граница среза не включительно.
        if title1 > title2:   # если названия не по алфавиту
            print("NO")
            break
    prev = curr               # запоминаем текущую как предыдущую
else:
    print("YES")

s1, s2, flag = '', '', 'YES'
for i in range(int(input())):
    s = input()
    s1 = s2
    s2 = s.replace(s[s.find(' '):s.find('«')], '')
    if s2 < s1:
        flag = 'NO'
        break
print(flag)

s = '###Python rocks!####'
print(s.strip('#'))

# На вход программе подаётся строка текста. Напишите программу, которая удаляет из нее все символы
# с индексами, кратными 3, то есть символы с индексами 0, 3, 6, ....
s = input()
for i in range(len(s)):
    if i % 3 != 0:
        print(s[i], end='')

s = input()
n = len(s)
new_s = ""
for i in range(n):
    if i % 3 == 0:
        continue
    new_s += s[i]
print(new_s)

# На вход программе подаётся строка текста. Напишите программу, которая заменяет все вхождения
# цифры 1 на слово «one».
s = input()
print(s.replace('1', 'one'))

# На вход программе подаётся строка текста. Напишите программу, которая удаляет все вхождения символа «@».
s = input()
print(s.replace('@', ''))

s = input()
a = ""
for i in range(len(s)):
    if s[i] != "@":
        a += s[i]
print(a)

# На вход программе подаётся строка текста. Напишите программу, которая выводит индекс второго
# вхождения буквы «f». Если буква «f» встречается только один раз, выведите число «-1» (без кавычек),
# а если не встречается ни разу – выведите число «-2» (без кавычек).
s = input()
if s.count('f') > 1:
    first = s.find('f')
    second = s.find('f', first + 1)  # ищем следующее f, начиная после первого
    print(second)
elif s.count('f') == 1:
    print(-1)
else:
    print(-2)

s = input()
if s.count("f") == 0:
    print(-2)
elif s.count("f") == 1:
    print(-1)
else:
    res = s.replace("f", ".", 1).find("f")
    print(res)

s = input()
f = s.count('f')
if f > 1:
    print(f)
elif f == 1:
    print(-1)
elif f == 0:
    print(-2)

# На вход программе подаётся строка текста, в которой буква «h» встречается как минимум два раза.
# Напишите программу, которая возвращает исходную строку и переворачивает последовательность символов,
# заключённую между первым и последним вхождением буквы «h».
s = input()
t = s.find('h')  # индекс первого 'h'
p = s.rfind('h')  # индекс последнего 'h'
result = s[:t + 1] + s[t + 1:p][::-1] + s[p:]
# s[:t + 1] все символы до и включая первый символ 'h'
# s[t + 1:p] подстрока между первым 'h' и последним 'h'
# [::-1] разворачивает подстроку
# s[p:] часть от последнего 'h' до конца
print(result)

s = input()
a = int(s.find('h'))
b = int(s.rfind('h'))
print(s[:a]+s[b:a:-1]+s[b:])



